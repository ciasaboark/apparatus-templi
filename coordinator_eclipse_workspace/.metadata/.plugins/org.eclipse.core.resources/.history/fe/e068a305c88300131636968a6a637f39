package org.apparatus_templi;

public class LedFlash extends Coordinator implements ControlerModule, Runnable {
	private String moduleName = "LED_FLASH";
	private volatile boolean running = true;
	
	@Override
	public String getModuleType() {
		return "Controler";
	}

	@Override
	public String getModuleName() {
		return moduleName;
	}
	
	@Override
	public void terminate() {
		running = false;
	}

	/*
	 * Since every driver is exited to have intimate knowledge of
	 * the remote module that it corresponds with this can be a hard
	 * coded XML response.
	 */
	@Override
	public String getControlerListXML() {
		return new String(	"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
							"<controlerList>" +
								"<controler>" +
									"<name>LED 1</name>" +
								"</controler>" +
								"<controler>" +
									"<name>LED 2</name>" +
								"</controler>" +
								"<controler>" +
									"<name>LED 1</name>" +
								"</controler>" +
							"</controlerList>");
						
	}
	
	@Override
	public String getControlerStatusXML(String controllerName) {
		return new String(	"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
				"<controlerStatus>" +
				"<"
	}

	/*
	 * This method will be called by the Coordinator on behalf
	 * of the front-ends.  It is up to you do validate the incoming
	 * controllerName and command (if desired).  In this case we will
	 * switch based off the controllerName.  Since the only thing that
	 * this driver does is flash the LED we do not even have to check the
	 * command.
	 */
	@Override
	public void tellController(String controllerName, String command) {
		switch (controllerName) {
			case "LED 1":
				super.sendCommand(moduleName, "4");
				break;
			case "LED 2":
				super.sendCommand(moduleName, "5");
				break;
			case "LED 3":
				super.sendCommand(moduleName, "6");
				break;
			default:
				super.logMessage(moduleName, "tellController() Given invalid LED name");
				break;
		}
	}

	/*
	 * Our starting point of execution for this driver.
	 * This simply runs a loop sending commands to flash LEDs attached to
	 * different pins.  The driver does not care about responses from the
	 * remote module, so receiveMessage() is left unimplemented.  If the
	 * Coordinator needs to shut down this thread it can do so through the
	 * terminate() method, which will make the while loop exit
	 * 
	 * The startup procedure is very simple, ask the Coordinator if the
	 * remote module is active.  If it isn't, then terminate, else begin sending
	 * commands 
	 */
	@Override
	public void run() {
		if (super.isModulePresent(moduleName)) {
			while (running) {
				/*
				 * This is our main loop.  All of the processing will happen here
				 * Our simple driver will repeatedly send three messages to the
				 * remote module, sleeping 5 seconds between each message.
				 */
				for (int i = 3; i < 6; i++) {
					super.sendCommand(moduleName, String.valueOf(i));
					try {
						Thread.sleep(5000);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
		}
	}

	/*
	 * We don't care about any response messages.
	 */
	@Override
	public void receiveMessage(String message) {}

}
